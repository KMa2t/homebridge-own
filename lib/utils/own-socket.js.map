{"version":3,"sources":["../../src/utils/own-socket.js"],"names":[],"mappings":";;;;;;;;AAAA;;AACA;;;;;;;;IAEqB,c;AAMnB,0BAAY,IAAZ,EAAkB,IAAlB,EAAwB;AAAA;;AACtB,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,IAAL,GAAY,IAAZ;AACD;;;;yBAEI,O,EAAS,Q,EAAU;AACtB,qBAAe,IAAf,CAAoB,KAAK,IAAzB,EAA+B,KAAK,IAApC,EAA0C,OAA1C,EAAmD,QAAnD;AACD;;;iCAEmB,G,EAAK;AACvB,UAAI,QAAQ,eAAe,GAA3B,EAAgC;AAC9B,eAAO,EAAC,KAAK,IAAN,EAAP;AACD,OAFD,MAEO,IAAI,QAAQ,eAAe,IAA3B,EAAiC;AACtC,eAAO,EAAC,KAAK,KAAN,EAAP;AACD;AACD,aAAO,EAAC,KAAK,GAAN,EAAP;AACD;;;yBAEW,I,EAAM,I,EAAM,O,EAAS,Q,EAAU;AACzC,UAAM,SAAS,IAAI,cAAI,MAAR,EAAf;AACA,UAAI,YAAY,EAAhB;;AAEA;AACA,aAAO,OAAP,CAAe;AACb,kBADa;AAEb;AAFa,OAAf,EAGG,YAAM;AACP,eAAO,GAAP,CAAW,OAAX;AACD,OALD;;AAOA;AACA,aAAO,EAAP,CAAU,KAAV,EAAiB,YAAM;AACrB,YAAI,WAAW,KAAf;AACA,YAAM,oBAAoB,EAA1B;AACA,kBAAU,OAAV,CAAkB,UAAC,QAAD,EAAW,KAAX,EAAqB;AACrC,cAAM,MAAM,eAAe,YAAf,CAA4B,QAA5B,CAAZ;AACA,cAAI,UAAU,CAAV,IAAe,IAAI,GAAvB,EAA4B,OAFS,CAED;AACpC,cAAI,CAAC,IAAI,GAAT,EAAc;AACZ,uBAAW,IAAX;AACA;AACD;AACD,cAAI,IAAI,GAAR,EAAa;AACX,8BAAkB,IAAlB,CAAuB,IAAI,GAA3B;AACD;AACF,SAVD;;AAYA,iBAAS,WAAW,IAAI,KAAJ,CAAU,MAAV,CAAX,GAA+B,IAAxC,EAA8C,iBAA9C;AACD,OAhBD;;AAkBA;AACA,aAAO,EAAP,CAAU,MAAV,EAAkB,UAAC,GAAD,EAAS;AACzB,oBAAY,UAAU,MAAV,CAAiB,mBAAM,IAAI,QAAJ,GAAe,KAAf,CAAqB,eAAe,OAApC,CAAN,EAC1B,MAD0B,CACnB,UAAC,GAAD;AAAA,iBAAS,QAAQ,EAAjB;AAAA,SADmB,EAE1B,GAF0B,CAEtB,UAAC,GAAD;AAAA,sBACA,GADA,GACM,eAAe,OADrB;AAAA,SAFsB,EAIzB,KAJyB,EAAjB,CAAZ;AAKD,OAND;AAOD;;;;;;AA/DkB,c,CACZ,G,GAAM,Q;AADM,c,CAEZ,I,GAAO,Q;AAFK,c,CAIZ,O,GAAU,I;kBAJE,c","file":"own-socket.js","sourcesContent":["import {chain} from 'lodash';\nimport net from 'net';\n\nexport default class OwnSocketUtils {\n  static ACK = '*#*1##';\n  static NACK = '*#*0##';\n\n  static MSG_SEP = '##';\n\n  constructor(host, port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  send(message, callback) {\n    OwnSocketUtils.send(this.host, this.port, message, callback);\n  }\n\n  static readResponse(res) {\n    if (res === OwnSocketUtils.ACK) {\n      return {ack: true};\n    } else if (res === OwnSocketUtils.NACK) {\n      return {ack: false};\n    }\n    return {msg: res};\n  }\n\n  static send(host, port, message, callback) {\n    const socket = new net.Socket();\n    let responses = [];\n\n    // Send message after connection\n    socket.connect({\n      port,\n      host\n    }, () => {\n      socket.end(message);\n    });\n\n    // Send response on end\n    socket.on('end', () => {\n      let hasError = false;\n      const returnedResponses = [];\n      responses.forEach((response, index) => {\n        const res = OwnSocketUtils.readResponse(response);\n        if (index === 0 && res.ack) return; // Ignore first ack\n        if (!res.ack) {\n          hasError = true;\n          return;\n        }\n        if (res.msg) {\n          returnedResponses.push(res.msg);\n        }\n      });\n\n      callback(hasError ? new Error('NACK') : null, returnedResponses);\n    });\n\n    // Append data to responses (resplit if necessary)\n    socket.on('data', (buf) => {\n      responses = responses.concat(chain(buf.toString().split(OwnSocketUtils.MSG_SEP))\n        .filter((res) => res !== '')\n        .map((res) =>\n          `${res}${OwnSocketUtils.MSG_SEP}`\n        ).value());\n    });\n  }\n}\n"]}