{"version":3,"sources":["../../src/utils/own-socket.js"],"names":["OwnSocketUtils","host","port","useConn","message","callback","send","res","ACK","ack","NACK","msg","console","log","socket","net","Socket","responses","connAck","connSend","connect","Promise","resolve","then","reject","once","buf","toString","tap","write","CONN","forEach","messageItem","on","hasError","returnedResponses","response","index","readResponse","push","Error","end","concat","split","MSG_SEP","filter","map","value"],"mappings":"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","file":"own-socket.js","sourcesContent":["import {chain, isArray} from 'lodash';\nimport net from 'net';\nimport Promise from 'bluebird';\n\nexport default class OwnSocketUtils {\n  static ACK = '*#*1##';\n  static NACK = '*#*0##';\n  static CONN = '*99*9##';\n\n  static MSG_SEP = '##';\n\n  constructor(host, port, useConn) {\n    this.host = host;\n    this.port = port;\n    this.useConn = useConn;\n  }\n\n  send(message, callback) {\n    OwnSocketUtils.send(this.host, this.port, this.useConn, message, callback);\n  }\n\n  static readResponse(res) {\n    if (res === OwnSocketUtils.ACK) {\n      return {ack: true};\n    } else if (res === OwnSocketUtils.NACK) {\n      return {ack: false};\n    }\n    return {msg: res};\n  }\n\n  static send(host, port, useConn, message, callback) {\n    console.log(`Establishing connection to ${host}`);\n    const socket = new net.Socket();\n    let responses = [];\n\n    let connAck = false;\n    let connSend = false;\n\n    // Send message after connection\n    socket.connect({\n      port,\n      host\n    }, () => {\n      return Promise.resolve()\n        .then(() => {\n          if (!useConn) return true;\n          return new Promise((resolve, reject) => {\n            socket.once('data', (buf) => {\n              if (buf.toString() === OwnSocketUtils.ACK) return resolve();\n              return reject();\n            });\n          })\n          .tap(() => {\n            connAck = true;\n            console.log('Connected.');\n          })\n          .then(() => {\n            console.log('Send CONN');\n            socket.write(OwnSocketUtils.CONN);\n            return new Promise((resolve, reject) => {\n              socket.once('data', (buf) => {\n                if (buf.toString() === OwnSocketUtils.ACK) {\n                  // connSend = true;\n                  return resolve();\n                }\n                return reject();\n              });\n            });\n          })\n          .tap(() => {\n            console.log('Authorized.');\n          })\n        })\n        .then(() => {\n          if (isArray(message)) {\n            message.forEach((messageItem) => {\n              console.log(`write ${messageItem}`);\n              socket.write(messageItem);\n            });\n            // socket.end();\n          } else {\n            console.log(`write single ${message}`);\n            socket.write(message);\n            // socket.end();\n          }\n        })\n\n\n    });\n\n    // Send response on end\n    socket.on('end', () => {\n      console.log('end');\n      let hasError = false;\n      const returnedResponses = [];\n      responses.forEach((response, index) => {\n        const res = OwnSocketUtils.readResponse(response);\n        // if (index === 0 && res.ack) {\n        //   console.log('ACK');\n        //   return; // Ignore first ack\n        // }\n        if (res.ack === false) {\n          console.log('NACK');\n          hasError = true;\n          return;\n        }\n        if (res.msg) {\n          console.log(`RES : ${res.msg}`);\n          returnedResponses.push(res.msg);\n        }\n      });\n\n      callback(hasError ? new Error('NACK') : null, returnedResponses);\n    });\n\n    // Append data to responses (resplit if necessary)\n    socket.on('data', (buf) => {\n      const res = buf.toString();\n      if (res === OwnSocketUtils.ACK && !connAck) {\n        connAck = true;\n        return;\n      }\n      if (res === OwnSocketUtils.ACK && !connSend) {\n        connSend = true;\n        return;\n      }\n      if (res === OwnSocketUtils.ACK && connSend && connAck) {\n        socket.end();\n      }\n      responses = responses.concat(chain(buf.toString().split(OwnSocketUtils.MSG_SEP))\n        .filter((res) => res !== '')\n        .map((res) =>\n          `${res}${OwnSocketUtils.MSG_SEP}`\n        ).value());\n    });\n  }\n}\n"]}