{"version":3,"sources":["../../src/utils/own-socket.js"],"names":["OwnSocketUtils","host","port","useConn","message","callback","send","res","ACK","ack","NACK","msg","socket","net","Socket","responses","connAck","connSend","connect","Promise","resolve","then","reject","once","buf","toString","write","CONN","forEach","messageItem","on","hasError","returnedResponses","response","index","readResponse","push","Error","end","concat","split","MSG_SEP","filter","map","value"],"mappings":"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","file":"own-socket.js","sourcesContent":["import {chain, isArray} from 'lodash';\nimport net from 'net';\nimport Promise from 'bluebird';\n\nexport default class OwnSocketUtils {\n  static ACK = '*#*1##';\n  static NACK = '*#*0##';\n  static CONN = '*99*9##';\n\n  static MSG_SEP = '##';\n\n  constructor(host, port, useConn) {\n    this.host = host;\n    this.port = port;\n    this.useConn = useConn;\n  }\n\n  send(message, callback) {\n    OwnSocketUtils.send(this.host, this.port, this.useConn, message, callback);\n  }\n\n  static readResponse(res) {\n    if (res === OwnSocketUtils.ACK) {\n      return {ack: true};\n    } else if (res === OwnSocketUtils.NACK) {\n      return {ack: false};\n    }\n    return {msg: res};\n  }\n\n  static send(host, port, useConn, message, callback) {\n    // console.log(`Establishing connection to ${host}`);\n    const socket = new net.Socket();\n    let responses = [];\n\n    let connAck = false;\n    let connSend = false;\n\n    // Send message after connection\n    socket.connect({\n      port,\n      host\n    }, () => {\n      return Promise.resolve()\n        .then(() => {\n          if (!useConn) return true;\n          return new Promise((resolve, reject) => {\n            socket.once('data', (buf) => {\n              if (buf.toString() === OwnSocketUtils.ACK) return resolve();\n              return reject();\n            });\n          })\n          .then(() => {\n            // console.log('Send CONN');\n            socket.write(OwnSocketUtils.CONN);\n            return new Promise((resolve, reject) => {\n              socket.once('data', (buf) => {\n                if (buf.toString() === OwnSocketUtils.ACK) {\n                  // connSend = true;\n                  return resolve();\n                }\n                return reject();\n              });\n            });\n          })\n        })\n        .then(() => {\n          if (isArray(message)) {\n            message.forEach((messageItem) => {\n              // console.log(`write ${messageItem}`);\n              socket.write(messageItem);\n            });\n            // socket.end();\n          } else {\n            // console.log(`write single ${message}`);\n            socket.write(message);\n            // socket.end();\n          }\n        })\n\n\n    });\n\n    // Send response on end\n    socket.on('end', () => {\n      // console.log('end');\n      let hasError = false;\n      const returnedResponses = [];\n      responses.forEach((response, index) => {\n        const res = OwnSocketUtils.readResponse(response);\n        // if (index === 0 && res.ack) {\n        //   console.log('ACK');\n        //   return; // Ignore first ack\n        // }\n        if (res.ack === false) {\n          // console.log('NACK');\n          hasError = true;\n          return;\n        }\n        if (res.msg) {\n          // console.log(`RES : ${res.msg}`);\n          returnedResponses.push(res.msg);\n        }\n      });\n\n      callback(hasError ? new Error('NACK') : null, returnedResponses);\n    });\n\n    // Append data to responses (resplit if necessary)\n    socket.on('data', (buf) => {\n      const res = buf.toString();\n      if (res === OwnSocketUtils.ACK && !connAck) {\n        connAck = true;\n        return;\n      }\n      if (res === OwnSocketUtils.ACK && !connSend) {\n        connSend = true;\n        return;\n      }\n      if (res === OwnSocketUtils.ACK && connSend && connAck) {\n        socket.end();\n      }\n      responses = responses.concat(chain(buf.toString().split(OwnSocketUtils.MSG_SEP))\n        .filter((res) => res !== '')\n        .map((res) =>\n          `${res}${OwnSocketUtils.MSG_SEP}`\n        ).value());\n    });\n  }\n}\n"]}