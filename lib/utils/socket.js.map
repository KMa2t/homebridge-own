{"version":3,"sources":["../../src/utils/socket.js"],"names":[],"mappings":";;;;;;;;AAAA;;AACA;;;;;;;;IAEqB,W;AAMnB,uBAAY,IAAZ,EAAkB,IAAlB,EAAwB;AAAA;;AACtB,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,IAAL,GAAY,IAAZ;AACD;;;;yBAEI,O,EAAS,Q,EAAU;AACtB,kBAAY,IAAZ,CAAiB,KAAK,IAAtB,EAA4B,KAAK,IAAjC,EAAuC,OAAvC,EAAgD,QAAhD;AACD;;;iCAEmB,G,EAAK;AACvB,UAAI,QAAQ,YAAY,GAAxB,EAA6B;AAC3B,eAAO,EAAC,KAAK,IAAN,EAAP;AACD,OAFD,MAEO,IAAI,QAAQ,YAAY,IAAxB,EAA8B;AACnC,eAAO,EAAC,KAAK,KAAN,EAAP;AACD;AACD,aAAO,EAAC,KAAK,GAAN,EAAP;AACD;;;yBAEW,I,EAAM,I,EAAM,O,EAAS,Q,EAAU;AACzC,UAAM,SAAS,IAAI,cAAI,MAAR,EAAf;AACA,UAAI,YAAY,EAAhB;;AAEA;AACA,aAAO,OAAP,CAAe;AACb,kBADa;AAEb;AAFa,OAAf,EAGG,YAAM;AACP,eAAO,GAAP,CAAW,OAAX;AACD,OALD;;AAOA;AACA,aAAO,EAAP,CAAU,KAAV,EAAiB,YAAM;AACrB,YAAI,WAAW,KAAf;AACA,YAAM,oBAAoB,EAA1B;AACA,kBAAU,OAAV,CAAkB,UAAC,QAAD,EAAW,KAAX,EAAqB;AACrC,cAAM,MAAM,YAAY,YAAZ,CAAyB,QAAzB,CAAZ;AACA,cAAI,UAAU,CAAV,IAAe,IAAI,GAAvB,EAA4B,OAFS,CAED;AACpC,cAAI,IAAI,IAAR,EAAc;AACZ,uBAAW,IAAX;AACA;AACD;AACD,cAAI,IAAI,GAAR,EAAa;AACX,8BAAkB,IAAlB,CAAuB,IAAI,GAA3B;AACD;AACF,SAVD;;AAYA,iBAAS,WAAW,IAAI,KAAJ,CAAU,MAAV,CAAX,GAA+B,IAAxC,EAA8C,iBAA9C;AACD,OAhBD;;AAkBA;AACA,aAAO,EAAP,CAAU,MAAV,EAAkB,UAAC,GAAD,EAAS;AACzB,oBAAY,UAAU,MAAV,CAAiB,mBAAM,IAAI,QAAJ,GAAe,KAAf,CAAqB,YAAY,OAAjC,CAAN,EAC1B,MAD0B,CACnB,UAAC,GAAD;AAAA,iBAAS,QAAQ,EAAjB;AAAA,SADmB,EAE1B,GAF0B,CAEtB,UAAC,GAAD;AAAA,sBACA,GADA,GACM,YAAY,OADlB;AAAA,SAFsB,EAIzB,KAJyB,EAAjB,CAAZ;AAKD,OAND;AAOD;;;;;;AA/DkB,W,CACZ,G,GAAM,Q;AADM,W,CAEZ,I,GAAO,Q;AAFK,W,CAIZ,O,GAAU,I;kBAJE,W","file":"socket.js","sourcesContent":["import {chain} from 'lodash';\nimport net from 'net';\n\nexport default class SocketUtils {\n  static ACK = '*#*1##';\n  static NACK = '*#*0##';\n\n  static MSG_SEP = '##';\n\n  constructor(host, port) {\n    this.host = host;\n    this.port = port;\n  }\n\n  send(message, callback) {\n    SocketUtils.send(this.host, this.port, message, callback);\n  }\n\n  static readResponse(res) {\n    if (res === SocketUtils.ACK) {\n      return {ack: true};\n    } else if (res === SocketUtils.NACK) {\n      return {ack: false};\n    }\n    return {msg: res};\n  }\n\n  static send(host, port, message, callback) {\n    const socket = new net.Socket();\n    let responses = [];\n\n    // Send message after connection\n    socket.connect({\n      port,\n      host\n    }, () => {\n      socket.end(message);\n    });\n\n    // Send response on end\n    socket.on('end', () => {\n      let hasError = false;\n      const returnedResponses = [];\n      responses.forEach((response, index) => {\n        const res = SocketUtils.readResponse(response);\n        if (index === 0 && res.ack) return; // Ignore first ack\n        if (res.nack) {\n          hasError = true;\n          return;\n        }\n        if (res.msg) {\n          returnedResponses.push(res.msg);\n        }\n      });\n\n      callback(hasError ? new Error('NACK') : null, returnedResponses);\n    });\n\n    // Append data to responses (resplit if necessary)\n    socket.on('data', (buf) => {\n      responses = responses.concat(chain(buf.toString().split(SocketUtils.MSG_SEP))\n        .filter((res) => res !== '')\n        .map((res) =>\n          `${res}${SocketUtils.MSG_SEP}`\n        ).value());\n    });\n  }\n}\n"]}